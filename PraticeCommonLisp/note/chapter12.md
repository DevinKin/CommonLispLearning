- [第12章-列表处理](#sec-1)
  - ["没有列表"](#sec-1-1)
  - [函数式变成和列表](#sec-1-2)
  - ["破坏性"操作](#sec-1-3)
  - [组合回收性函数和共享结构](#sec-1-4)
  - [列表处理函数](#sec-1-5)
  - [映射](#sec-1-6)

# 第12章-列表处理<a id="sec-1"></a>

## "没有列表"<a id="sec-1-1"></a>

理解列表的关键在于，要理解他们很大成都上是一种构建在更基本数据实例对象之上的描述，那些更简单的对象是成为点对单元(cons cell)的成对的值。使用函数 `CONS` 可以创建它们。

`CONS` 接受两个实参并返回一个含有两个值的新点对单元，这些值可以是对任何类型对象的引用。

除非第二个值是 `NIL` 或是另一个点对单元，否则点对豆浆打印成括号中并用一个点分隔两个值的形式。称为"点对"。

```common-lisp
(cons 1 2)
;;(1 . 2)
```

点对单元中的两个值分别称为 `CAR` 和 `CDR` ，它们同时也是用来访问两个值的函数名。

```common-lisp
(car (cons 1 2))
;;1
(cdr (cons 1 2))
;;2
```

`CAR` 和 `CDR` 支持 `SETF` 的位置，即给定一个已有的点对y大暖，有可能将新的值赋给它的任何一个值。

```common-lisp
(defparameter *cons* (cons 1 2))
(setf (car *cons*) 10)
(setf (cdr *cons*) 20)

```

从列表角度考虑， `FIRST` 和 `REST` 分别是 `CAR` 和 `CDR` 的同义词。

```common-lisp
(defparameter *list* (list 1 2 3 4))
(first *list*)
(rest *list*)
(first (rest *list*))
```

## 函数式变成和列表<a id="sec-1-2"></a>

函数式变成的本质在于，程序完全没有副作用的函数组成，函数完全基于其参数的值来计算结果。

任何接受一个列表作为实参切返回值完全以来于列表内容的函数，同样认为是函数式的。

## "破坏性"操作<a id="sec-1-3"></a>

在Lisp的函数式传统，修改已有对象的操作被称为是破坏性的。改变一个对象的状态相当于"破坏"了它，因为它不能再代表相同的那个值了。

存在两种相当不同的破坏性操作

-   副作用操作
-   回收性操作

副作用性操作是那些专门利用其副作用的操作，如 `SETF` 、 `VECTOR-PUSH` 或 `VECTOR-POP` 修改已有对象状态的函数。

如果将非函数式的副作用性操作和那些返回结构共享结果的函数混合使用，那么就要小心不要疏忽地修改了共享的结构。

```common-lisp
(defparameter *list-1* (list 1 2))
(defparameter *list-2* (list 3 4))
(defparameter *list-3* (append *list-1* *list-2*))
;; list-3 共享了 list-1 和 list-2 结构
(setf (first *list-2*) 0)
*list-2*
;;(0 4)
*list-3*
;;(1 2 0 4)
```

回收性操作，其本来就是用于函数式代码中的。它们的副作用仅是一种优化手段。特别地，它们在构造结果时会重用来自它们实参的特定点对单元。

-   只有当调用回收性函数之后不再需要原先列表的情况下，回收性函数才可以被安全地使用。

```common-lisp
(setf *list* (reverse *list*))
```

在许多Lisp实现中，立即重用已有的点对单元会比分配新的点对单元并让老的变成垃圾更加有效。

`NREVERSE` 函数名字中的 `N` 的含义是 `non-consing` ，意思是它不需要重新分配任何新的点对单元。

常用的回收性函数 `NCONC` 是 `APPEND` 的回收性版本。 `DELETE` 、 `DELETE-IF` 、 `DELETE-IF-NOT` 和 `DELETE-DUPLICATES` 则是序列函数的REMOVE家族的回收性版本。

对于传递给 `NCONC` 的没一个非空列表， `NCONC` 会将该列表的最后一个点对单元的 `CDR` 设置成指向下一个非空列表的地一个点对单元。然后返回地一个列表，后者是拼接在一起的结果的开始部分。

```common-lisp
(defparameter *x* (list 1 2 3))
(nconc *x* (list 4 5 6))   ;; append 返回的是(1 2 3)
*x*
;;(1 2 3 4 5 6)
```

`NSUBSTITUTE` 及其变体可靠地沿着列表实参的列表结构向下遍历，将任何带有旧值的点对单元的 `CAR` 部分 `SETF` 到新的之上，否则保持列表原封不动。然后它返回最初的列表，其带有与 `SUBSTITUTE` 计算得到的结果相同的之。

```common-lisp
(substitute)
```

关于 `NCONC` 和 `NSUBSTITUTE` ，关键要记住，它们是不能依赖于回收性函数的副作用这一规则的例外。忽视它们的副作用的可靠性，而像任何其他回收性函数一样使用它们，只用来产生返回值，这种做法不但完全可以接受，甚至还是一种良好的编程风格。

## 组合回收性函数和共享结构<a id="sec-1-4"></a>

非破坏性列表函数在对点单元永远不会修改的假设下返回带有共享结构的列表，但是回收性函数会修改点对单元。

使用共享结构是基于不在乎究竟是由哪些点对单元构成列表这一前提的，而使用回收性函数则要求精确地知道哪些点对单元会在哪里被引用到。

当操作列表时，最好是以函数式风格来编写自己的代码——函数应当只依赖于它们的列表实参的内容而不应该修改它们。

排序函数 `SORT` 、 `STABLE-SORT` 、 `MERGE` 应用于列表时，它们也是回收性函数。不过这些函数并没有破坏性的同伴，因此当需要对列表排序而又不破坏它时，你需要传给排序函数一个由 `COPY-LIST` 生成的列表的副本。

```common-lisp
(defparameter *list* (list 4 3 2 1))
(sort *list* #'<)
*list*
```

## 列表处理函数<a id="sec-1-5"></a>

Common Lisp提供了以从 `SECOND` 到 `TENTH` 的由其他序数命名的函数来返回相应的元素。

函数 `NTH` 接受两个参数，一个索引和一个列表，并返回列表中第n个(从0开始)元素。

函数 `NTHCDR` 接受一个索引和一个列表，并返回调用 `CDR` n次的结果。

28个复合 `CAR/CDR` 函数则是另一个不时会用到的函数家族。每个函数都是通过将由最多四个A和D组成的序列放在C和R之间来命名。

```common-lisp
(caar list)
(cadr list)
(cadadr lsit)
```

其他列表处理函数描述

| 函数      | 描述                                                              |
|--------- |----------------------------------------------------------------- |
| LAST      | 返回列表的最后一个点对单元。带有一个整数参数时，返回最后n个点对单元 |
| BUTLAST   | 返回列表的一个副本，最后一个点对单元除外。带有一个整数参数时，排除最后n个单元 |
| NBUTLAST  | BUTLAST的回收性版本。可能修改并返回其参数列表但缺少可靠的副作用   |
| LDIFF     | 返回列表直到某个给定点对单元的副本                                |
| TAILP     | 返回真，如果给定对象是作为列表的一部分点对单元                    |
| LIST\*    | 构造一个列表来保存除最后一个参数以外的所有参数，然后让最后一个参数成为这个列表最后一个节点的CDR，它组合了LIST和APPEND |
| MAKE-LIST | 构造一个n项列表。该列表的初始元素是NIL或通过。:initial-element关键字参数所指定的值 |
| REVAPPEND | REVERSE和APPEND的组合，像REVERSE那样求逆地一个参数，再将其追加到第二个参数上。没有可靠的副作用 |
| CONSP     | 用来测试一个对象是否为点对单元的谓词                              |
| ATOM      | 用来测试一个对象是否不是点对单元的谓词                            |
| LISP      | 用来测试一个对象是是否为点对单元或NIL的谓词                       |
| NULL      | 用来测试一个对象是否为NIL的为此。功能上等价于NOT但测试空列表而非布尔假时文体上推荐使用 |

## 映射<a id="sec-1-6"></a>

`MAPCAR` 返回一个列表，第一个参数是它要应用的函数，后续参数是其元素将为该函数提供实参的列表。

-   函数被应用在实参的相继元素上，每次函数的应用都会从每个列表中各接受一个元素，每次调用的结果都被收集到一个新列表中。

```common-lisp
(mapcar #'(lambda (x) (* 2 x)) (list 1 2 3))
(mapcar #'+ (list 1 2 3) (list 10 20 30))
```

`MAPLIST` 传递给函数的不是列表元素，而是实际的点对单元。函数不仅可以访问到列表中每个元素的值(通过CAR)，还可以访问到列表的其余部分(通过CDR)

`MAPCAR` 和 `MAPLIST` 会构造一个全新的列表来保存函数调用的结果， `MAPCAN` 和 `MAPCON` 则通过将结果(必须是列表)用 `NCONC` 拼接在一起来产生它们的结果。每次函数调用都可以向结果中提供任意数量的元素。

`MAPCAN` 像 `MAPCAR` 把列表的元素传递到映射函数中， `MAPCON` 像 `MAPLIST` 那样来传递点对单元

`mapc` 和 `MAPL` 是伪装成函数的控制构造，它们返回地一个列表是惨，只有当映射函数有的副作用有用时，这两个元素才有用。
